/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 *
 *
 * === ZFS Library ===
 *
 * This is an alternative library for managing ZFS using spawned
 * processes. It remains less than ideal.
 *
 * Sizes are normalized in MB (MegaBytes or 1024*1024)
 *
 * ### Implemented:
 *   - List Datasets
 *   - Get a single image
 *   - Receive Dataset (from a readable stream)
 *   - Send Dataset
 *   - Get a recursive list of images
 *   - Take a Snapshot of a Dataset
 *   - Delete a image (option recursively)
 *   - Get a image and its children as an array
 *
 * ### To Implement:
 *   - Rollback a Snapshot
 *
 */

var path = require('path');
var fs = require('fs');
var spawn = require('child_process').spawn;
var exec = require('child_process').exec;
var assert = require('assert');

var ZFS = '/usr/sbin/zfs';
var ZPOOL = '/usr/sbin/zpool';

var ZPOOL_PROPERTIES = [
    'alloc',
    'cap',
    'dedup',
    'free',
    'health',
    'name',
    'size'
];

var QUERY_PROPERTIES = [
    'available',
    'creation',
    'imgadm:urn',
    'imgadm:uuid',
    'name',
    'origin',
    'quota',
    'referenced',
    'type',
    'used',
    'usedbychildren',
    'usedbydataset',
    'usedbysnapshots',
    'volblocksize',
    'volsize'
];

var VOL_PROPERTIES = [
    'available',
    'creation',
    'imgadm:urn',
    'imgadm:uuid',
    'name',
    'origin',
    'referenced',
    'type',
    'used',
    'usedbychildren',
    'usedbydataset',
    'usedbysnapshots',
    'volblocksize',
    'volsize'
];

var SNAP_PROPERTIES = [
    'creation',
    'name',
    'type',
    'used'
];

var FS_PROPERTIES = [
    'available',
    'creation',
    'imgadm:urn',
    'imgadm:uuid',
    'name',
    'origin',
    'quota',
    'referenced',
    'type',
    'used',
    'usedbychildren',
    'usedbydataset',
    'usedbysnapshots'
];

var ERR_LIST = 10;
var ERR_SET = 11;
var ERR_RECV = 12;
var ERR_GET = 13;
var ERR_SEND = 14;
var ERR_EXIST = 20;
var ERR_RENAME = 21;
var ERR_SNAP = 22;
var ERR_DESTROY = 23;

var newError = function (code, message) {
    assert.ok(code);
    assert.ok(message);
    return JSON.stringify({error: {code: code, message: message}});
};

function toMB(value) {
    return Math.ceil(value / 1048676); // 1024*1024
}

function toMiB(value) {
    return Math.ceil(value / 1000000); // 1000*1000
}

var _formatPoolProperty = function (prop, val) {
    assert.ok(prop);
    assert.ok(val);

    if (val === '-') {
        return [prop, null];
    }

    switch (prop) {
        case 'size':
            val = toMB(val);
            break;
        case 'free':
            val = toMB(val);
            break;
        case 'alloc':
            val = toMB(val);
            break;
        default:
            // skip this property
            break;
    }
    return [prop, val];
};

var _formatRecord = function (record) {
    assert.ok(record);

    var format;
    var i;
    var result;

    format = function (rec, properties) {
        assert.ok(rec);
        assert.ok(properties);

        var p;
        var r = {};
        var v;

        for (i in properties) {
            p = properties[i];
            v = rec[p];
            r[p] = _formatProperty(p, v)[1];
        }
        return r;
    };

    switch (record.type) {
        case 'volume':
            result = format(record, VOL_PROPERTIES);
            break;
        case 'snapshot':
            result = format(record, SNAP_PROPERTIES);
            break;
        case 'filesystem':
            result = format(record, FS_PROPERTIES);
            break;
        default:
            throw new Error('Unknown record type: [' + record.type + ']');
    }

    return result;
};

var _formatProperty = function (prop, val) {
    assert.ok(prop);
    assert.ok(val);

    var d;

    if (val === '-') {
        return [prop, null];
    }

    switch (prop) {
        case 'sdc:dataset':
            if (val === null) {
                val = false;
            } else {
                val = true;
            }
            break;
        case 'used':
            val = toMB(val);
            break;
        case 'available':
            val = toMB(val);
            break;
        case 'referenced':
            val = toMB(val);
            break;
        case 'quota':
            val = toMB(val);
            break;
        case 'usedbydataset':
            val = toMB(val);
            break;
        case 'usedbysnapshots':
            val = toMB(val);
            break;
        case 'usedbychildren':
            val = toMB(val);
            break;
        case 'volsize':
            val = toMB(val);
            break;
        case 'volblocksize':
            val = parseInt(val, 10);
            break;
        case 'creation':
            d = (val * 1000);
            val = new Date(d).toJSON();
            break;
        default:
            // ignore
            break;
    }
    return [prop, val];
};

var setFilter = {
    image: function (ele, idx, arr) {
        return (ele['imgadm:uuid']);
    },
    origin: function (ele, idx, arr) {
        return (ele.origin);
    },
    snapshot: function (ele, idx, arr) {
        return (ele.type === 'snapshot');
    },
    volume: function (ele, idx, arr) {
        return (ele.type === 'volume');
    },
    filesystem: function (ele, idx, arr) {
        return (ele.type === 'filesystem');
    }
};

var get = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    var args = ['get', '-pH', '-o', 'property,value'];
    var data = '';
    var error = null;
    var parseData;
    var zfs;

    args.push(QUERY_PROPERTIES.join(','));
    args.push(name);

    zfs = spawn(ZFS, args);

    parseData = function () {
        var i;
        var image = {};
        var line;
        var lines;
        var prop;
        var val;

        lines = data.split(/\n/);
        for (i = 0; i < lines.length; i++) {
            line = lines[i].split(/\t/);
            prop = line[0];
            val = line[1];

            image[prop] = val;
        }
        callback(error, _formatRecord(image));
    };

    zfs.stdout.on('data', function (chunk) {
        data = data + chunk.toString();
    });

    zfs.on('exit', function (code, signal) {
        parseData();
    });
};

var getRecursive = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    var args = ['get', '-rpH', '-o', 'name,property,value'];
    var data = '';
    var error = null;
    var parseData;
    var zfs;

    args.push(QUERY_PROPERTIES.join(','));
    args.push(name);

    zfs = spawn(ZFS, args);

    parseData = function () {
        var i;
        var image = {};
        var images = [];
        var line;
        var lines;
        var old;
        var prop;
        var val;

        lines = data.split(/\n/);
        for (i = 0; i < lines.length; i++) {
            line = lines[i].split(/\t/);
            if (line.length === 1) {
                images.push(_formatRecord(image));
                break;
            }

            prop = line[1];
            val = line[2];

            if (old === name) {
                image[prop] = val;
            } else {
                old = name;
                if (image.name) {
                    images.push(_formatRecord(image));
                }
                image = {
                    name: name
                };
                image[prop] = val;
            }
        }
        callback(error, images);
    };

    zfs.stdout.on('data', function (chunk) {
        data = data + chunk.toString();
    });

    zfs.on('exit', function (code, signal) {
        parseData();
    });
};

var getClones = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    list(null, function (err, images) {
        var clones = [];
        var i;

        if (err) {
            callback(err, null);
            return;
        }
        for (i = 0; i < images.length; i++) {
            // console.log(images[i].name);
            if (images[i].origin === name) {
                clones.push(images[i]);
            }
        }
        callback(err, clones);
    });
};

var getSnapshots = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    getRecursive(name, function (err, images) {
        if (err) {
            callback(err, null);
            return;
        }
        images.shift(); // first result is the actual image

        callback(null, images);
    });
};

// returns a full list of all images
var list = function (options, callback) {
    var _options = {
        type: 'all' // valid are snapshot, vol,
    };
    var args = ['list', '-rpH', '-t', _options.type, '-o'];
    var data = '';
    var error = null;
    var parseData;
    var zfs;

    args.push(QUERY_PROPERTIES.join(','));

    zfs = spawn(ZFS, args);

    parseData = function () {
        var i;
        var image;
        var images = [];
        var line;
        var lines = data.split(/\n/);
        var p;
        var prop;
        var val;

        for (i = 0; i < lines.length; i++) {
            line = lines[i].split(/\t/);
            image = {};

            if (line.length === 1) {
                continue;
            }

            for (p = 0; p < QUERY_PROPERTIES.length; p++) {
                val = line[p];
                prop = QUERY_PROPERTIES[p];
                image[prop] = val;
            }

            images.push(_formatRecord(image));
        }
        callback(error, images);
    };

    zfs.stdout.on('data', function (chunk) {
        data = data + chunk.toString();
    });

    zfs.stderr.on('data', function (chunk) {
        callback(newError(ERR_LIST, 'error listing images'));
    });

    zfs.on('exit', function (code, signal) {
        parseData();
    });
};

var snapshot = function (name, options, callback) {
    assert.ok(name);
    var _options = {
        recursive: false,  // bool
        property: null     // must be an array
    };

    var args = ['snapshot'];
    var error = null;
    var zfs;

    if (_options.recursive === true) {
        args.push('-r');
    }
    if (_options.property) {
        args.push(_options.property[0] + '=' + _options.property[1]);
    }

    args.push(name);

    zfs = spawn(ZFS, args);

    zfs.stderr.on('data', function (chunk) {
        error = newError(ERR_SNAP, 'error taking snapshot' + chunk);
    });

    zfs.on('exit', function (code, signal) {
        callback(error);
    });
};

var destroy = function (name, options, callback) {
    assert.ok(name);

    var args = ['destroy'];
    var error = null;
    var zfs;

    if (!options) {
        options = { recursive: false };
    }

    if (options.recursive === true) {
        args.push('-r');
    }
    args.push(name);

    zfs = spawn(ZFS, args);

    zfs.stderr.on('data', function (chunk) {
        error = newError(ERR_DESTROY, 'error destroying snapshot' + chunk);
    });

    zfs.on('exit', function (code, signal) {
        callback(error);
    });
};

var setProp = function (name, property, value, callback) {
    assert.ok(name);
    assert.ok(property);
    assert.ok(value);
    assert.ok(callback);

    var args = ['set'];
    var err;
    var zfs;

    args.push(property + '=' + value);
    args.push(name);

    zfs = spawn(ZFS, args);

    zfs.on('exit', function (code, signal) {
        callback(err);
    });

    zfs.stderr.on('data', function (chunk) {
        err = newError(ERR_SET, 'error setting property' + chunk);
    });
};

var rename = function (name, newname, callback) {
    assert.ok(name);
    assert.ok(newname);

    var args = ['rename', name, newname];
    var zfs = spawn(ZFS, args);

    zfs.on('exit', function (code, signal) {
        if (callback) {
            callback(null);
        }
    });

    zfs.stderr.on('data', function (chunk) {
        if (callback) {
            callback(newError(ERR_RENAME, 'error renaming image'));
        }
    });
};

var receiveStream = function (name, readStream, callback) {
    assert.ok(name);
    assert.ok(readStream);
    assert.ok(callback);

    var args = ['recv']; // add '-n' when testing
    var _name = name; // + '-partial';
    var zfs;

    args.push(_name);

    zfs = spawn(ZFS, args);

    readStream.pipe(zfs.stdin); // ;)

    zfs.on('exit', function (code, signal) {
        return callback();
    });

    zfs.stderr.on('data', function (chunk) {
        callback(newError(ERR_RECV, 'error receiving image'));
    });
};

var spawnReceiveStream = function (name) {
    assert.ok(name);

    var args = ['recv'];
    var _name = name; // + '-partial';
    var zfs;

    args.push(_name);

    zfs = spawn(ZFS, args);

    return zfs; // cheating / felony
};

var sendStream = function (name, writeStream, callback) {
    assert.ok(name);
    assert.ok(writeStream);
    assert.ok(callback);

    var args = ['send'];
    var zfs;

    args.push(name);

    zfs = spawn(ZFS, args);

    zfs.stdout.pipe(writeStream);

    zfs.on('exit', function (code, signal) {
        callback(null);
    });

    zfs.stderr.on('data', function (chunk) {
        callback(newError(ERR_SEND, 'error sending image'));
    });
};

var getPool = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    var pool = {};

    listPool(null, function (err, pools) {
        var i;

        for (i = 0; i < pools.length; i++) {
            if (pools[i].name === name) {
                pool = pools[i];
            }
        }
        callback(err, pool);
    });
};

var listPool = function (options, callback) {
    assert.ok(callback);

    var args = ['list', '-pH', '-o'];
    var pools = [];
    var zpool;

    args.push(ZPOOL_PROPERTIES.join(','));

    zpool = spawn(ZPOOL, args);
    zpool.stdout.on('data', function (chunk) {
        var lines = chunk.toString().split(/\n/);
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].split(/\t/);
            var p;
            var prop;
            var pool = {};
            var val;

            if (line.length === 1) {
                continue;
            }

            for (p = 0; p < ZPOOL_PROPERTIES.length; p++) {
                val = line[p];
                prop = ZPOOL_PROPERTIES[p];

                val = _formatPoolProperty(prop, val)[1];

                pool[prop] = val;
            }

            pools.push(pool);
        }
    });

    zpool.on('exit', function (code, signal) {
        callback(null, pools);
    });
};

module.exports = {
    list: list,
    get: get,
    snapshot: snapshot,
    destroy: destroy,
    getRecursive: getRecursive,
    getClones: getClones,
    getSnapshots: getSnapshots,
    setProp: setProp,
    receiveStream: receiveStream,
    sendStream: sendStream,
    spawnReceiveStream: spawnReceiveStream,
    rename: rename,
    listPool: listPool,
    getPool: getPool
};
